# Story 3.4: Catalog API & Caching

## Status
Draft

## Story
**As a** storefront developer,
**I want** a typed catalog API,
**so that** UI surfaces card data efficiently and reliably.

## Acceptance Criteria
1. AC1: REST/GraphQL endpoints expose cards, prints, sets, and facets with pagination.
2. AC2: Responses cached with per-game TTL and invalidated after ETL completion.
3. AC3: API supports filtering by game, rarity, price range, vendor availability.
4. AC4: Integration tests cover end-to-end fetch from API to normalized data.

## Tasks / Subtasks
- [ ] Design API schema (REST or GraphQL) with typed DTOs covering catalog entities (AC1).
- [ ] Implement caching layer (Redis) keyed by query parameters with per-game TTL (AC2).
- [ ] Add filter support and validation for game, rarity, price, vendor flags (AC3).
- [ ] Wire ETL completion events to trigger cache invalidation (AC2).
- [ ] Build integration test suite hitting API and verifying transformed data (AC4).
- [ ] Publish API documentation/OpenAPI spec for frontend consumers (AC1-AC3).

## Dev Notes
- Service entrypoint under `customer-backend/src/routes/catalog`; consider using Nest/Express controllers per existing pattern.
- Use `zod` or custom validators for query parameters; ensure pagination includes cursors.
- Cache invalidation should respond to ETL job status from Story 3.1.
- Provide typed SDK in `storefront/src/lib/api/catalog-client.ts` for consistent usage.
- Monitor cache hit ratio and API latency via existing observability stack.

## Testing
- Integration tests using test database with seeded catalog data.
- Contract tests verifying OpenAPI schema matches implementation.
- Performance tests to confirm latency <100ms under load with cache warm.
- Frontend smoke test fetching catalog data via new client.

## Change Log
| Date       | Version | Description              | Author |
|------------|---------|--------------------------|--------|
| 2025-09-13 | 0.1.0   | Initial story draft      | Codex  |

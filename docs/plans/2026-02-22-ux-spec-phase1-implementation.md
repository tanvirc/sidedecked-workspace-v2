# UX Spec Phase 1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Establish the Phase 1 foundation from the UX design spec — shadcn/ui setup, browser dialog elimination, and three new TCG presentation components.

**Architecture:** Install Radix/shadcn primitives alongside existing components (no migration required). Replace 35+ browser `alert()` and 3 `confirm()` calls with sonner toasts and AlertDialog. Build `<RarityBadge>`, `<PriceTag>`, `<CardDisplay>` in `src/components/tcg/`, then refactor `CardGridItem` and `ListingCard` to use them internally.

**Tech Stack:** Next.js 14, Tailwind CSS, shadcn/ui (Radix UI), sonner, Vitest + @testing-library/react

---

## Task 1: shadcn/ui init + install Radix components

**Working directory:** `storefront/`

**Files created:**
- `components.json` (generated by shadcn init)
- `src/components/ui/sheet.tsx`
- `src/components/ui/dialog.tsx`
- `src/components/ui/alert-dialog.tsx`
- `src/components/ui/tooltip.tsx`
- `src/components/ui/popover.tsx`
- `src/components/ui/dropdown-menu.tsx`
- `src/components/ui/command.tsx`
- `src/components/ui/sonner.tsx`

**Step 1: Initialize shadcn**

Run this from `storefront/`:
```bash
npx shadcn@latest init
```

When prompted (it's interactive):
- Style: Default
- Base color: Neutral (closest to existing tokens)
- CSS variables: Yes
- Config: Accept auto-detected tailwind.config.ts

This generates `components.json`. If it modifies `globals.css` or `tailwind.config.ts`, review the diff and revert any token changes (our `colors.css` already defines all Midnight Forge tokens correctly — do not let shadcn overwrite them).

**Step 2: Install all shadcn components**

```bash
npx shadcn@latest add sheet dialog alert-dialog tooltip popover dropdown-menu command sonner
```

Each component installs into `src/components/ui/`. Confirm each file exists after.

**Step 3: Remove @headlessui/react**

```bash
npm uninstall @headlessui/react
```

Then search for any imports:
```bash
grep -r "@headlessui" src/ --include="*.tsx" --include="*.ts"
```

If any results: those components must be rewritten before removing. If none: proceed.

**Step 4: Add Toaster to root providers**

Modify `src/app/providers.tsx` — add the sonner Toaster:

```tsx
import { Toaster } from "@/components/ui/sonner"

// Inside the Providers component's return, add at the end:
<Toaster position="bottom-right" richColors />
```

For the deck builder (Phase 2), the Toaster position will need to switch to `top-right`. For now, `bottom-right` is correct for all views.

**Step 5: Run quality check**

```bash
npm run typecheck && npm run lint
```

Expected: 0 errors (shadcn components are pre-typed). If there are shadcn import errors, confirm `@/components/ui/` path alias matches `tsconfig.json`.

**Step 6: Commit**

```bash
git add -A
git commit -m "chore(storefront): initialize shadcn/ui and install Radix primitives"
```

---

## Task 2: Replace confirm() and prompt() calls with AlertDialog

**Context:** Found 3 browser `confirm()` / `window.confirm()` calls:
1. `src/components/deck-builder/DeckZone.tsx:86` — `if (confirm('Clear all cards from ${title}?'))`
2. `src/components/seller/ConsumerSellerDashboard.tsx:209` — `if (!window.confirm(...))`
3. `src/hooks/useFeedback.tsx:79` — `const confirmed = window.confirm(confirmationMessage)`

The AlertDialog pattern requires converting synchronous `confirm()` to async with React state.

**Files modified:**
- `src/components/deck-builder/DeckZone.tsx`
- `src/components/seller/ConsumerSellerDashboard.tsx`
- `src/hooks/useFeedback.tsx`

**Step 1: Write test for DeckZone confirmation**

Create `src/components/deck-builder/__tests__/DeckZone.test.tsx`:

```tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'

// We'll test that confirm() is NOT called (browser dialogs forbidden)
describe('DeckZone', () => {
  it('does not call window.confirm when clearing cards', async () => {
    const confirmSpy = vi.spyOn(window, 'confirm').mockReturnValue(true)
    // Import and render DeckZone with cards — trigger clear action
    // Then assert confirm was never called
    expect(confirmSpy).not.toHaveBeenCalled()
    confirmSpy.mockRestore()
  })
})
```

Run: `npm run test -- src/components/deck-builder/__tests__/DeckZone.test.tsx`

This test is a canary — it will pass now (confirm not yet triggered) and should pass after migration too.

**Step 2: Read DeckZone.tsx line 86 context**

Read `src/components/deck-builder/DeckZone.tsx` lines 75-100 to understand what action triggers the confirm.

**Step 3: Convert DeckZone confirm() to AlertDialog**

The pattern for converting sync `confirm()` to AlertDialog:

```tsx
// Add imports at top:
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"

// Add state near other useState declarations:
const [clearDialogOpen, setClearDialogOpen] = useState(false)

// Replace:
//   if (confirm(`Clear all cards from ${title}?`)) { ... }
// With:
//   setClearDialogOpen(true)

// And the actual action moves into onConfirm:
const handleClearConfirmed = () => {
  // ... the code that was inside the if(confirm) block
}

// Add to JSX (before closing tag of the component):
<AlertDialog open={clearDialogOpen} onOpenChange={setClearDialogOpen}>
  <AlertDialogContent>
    <AlertDialogHeader>
      <AlertDialogTitle>Clear {title}?</AlertDialogTitle>
      <AlertDialogDescription>
        This will remove all cards from this zone. This cannot be undone.
      </AlertDialogDescription>
    </AlertDialogHeader>
    <AlertDialogFooter>
      <AlertDialogCancel>Cancel</AlertDialogCancel>
      <AlertDialogAction
        onClick={handleClearConfirmed}
        className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
      >
        Clear zone
      </AlertDialogAction>
    </AlertDialogFooter>
  </AlertDialogContent>
</AlertDialog>
```

**Step 4: Convert ConsumerSellerDashboard confirm()**

Read `src/components/seller/ConsumerSellerDashboard.tsx` lines 200-220.

Apply the same AlertDialog pattern. The listing title comes from `listing.title`. State: `const [deleteTarget, setDeleteTarget] = useState<string | null>(null)`.

Trigger: `setDeleteTarget(listing.id)` instead of calling `window.confirm()`.

AlertDialog onConfirm: execute the deletion logic with `deleteTarget` as the id, then `setDeleteTarget(null)`.

**Step 5: Convert useFeedback.tsx confirm()**

Read `src/hooks/useFeedback.tsx` around line 79.

The `window.confirm()` in a hook is the hardest to convert because hooks can't render JSX. Options:
1. Remove the confirm-based method from the hook (if it's only used in ConsumerSellerDashboard, which now has its own AlertDialog)
2. Return a "requestConfirmation" function that sets state in the calling component

Check where this hook method is used:
```bash
grep -rn "useFeedback" src/ --include="*.tsx" --include="*.ts"
```

If the `window.confirm` path in the hook is only used in one place (likely ConsumerSellerDashboard), remove it from the hook — the AlertDialog in Task 2 Step 4 already handles it. If used in multiple places, leave a `// TODO: replace with AlertDialog` comment (and create a GitHub issue after committing).

**Step 6: Run typecheck**

```bash
npm run typecheck
```

**Step 7: Commit**

```bash
git add src/components/deck-builder/DeckZone.tsx \
        src/components/seller/ConsumerSellerDashboard.tsx \
        src/hooks/useFeedback.tsx \
        src/components/deck-builder/__tests__/DeckZone.test.tsx
git commit -m "fix(storefront): replace confirm() dialogs with AlertDialog"
```

---

## Task 3: Replace alert() calls in CardDetailPage.tsx

**Context:** 28 `alert()` calls in `src/components/cards/CardDetailPage.tsx`. All are error paths in async handlers.

**Replacement mapping:**
- Error failures → `toast.error("message")` (persistent — user must dismiss)
- Missing data → `toast.error("message")`

**Tone guide (from UX spec "friend test"):**
- "No available variants found" → `toast.error("This card isn't available to buy right now")`
- "This card is not currently available for purchase" → `toast.error("No listings available for this card")`
- "Error finding product for this card" → `toast.error("Couldn't find this card — try refreshing")`
- "Failed to add to cart. Please try again." → `toast.error("Couldn't add to cart — try again")`
- "Failed to add to wishlist" → `toast.error("Couldn't save to wishlist — try again")`
- "Failed to add to deck" → `toast.error("Couldn't add to deck — try again")`
- "Failed to create deck" → `toast.error("Couldn't create deck — try again")`
- "Failed to add to collection" → `toast.error("Couldn't add to collection — try again")`
- "Unable to add card: missing catalog information" → `toast.error("Missing card data — try refreshing the page")`
- "Unable to determine game for this card" → `toast.error("Couldn't identify this card's game — try refreshing")`

**Step 1: Add sonner import to CardDetailPage.tsx**

At the top of `src/components/cards/CardDetailPage.tsx`, add:
```tsx
import { toast } from "sonner"
```

**Step 2: Replace all alert() calls**

Do a find-and-replace, transforming each `alert('...')` to `toast.error('...')` using the tone guide above. The exact locations are lines: 130, 133, 136, 140, 209, 212, 216, 247, 251, 268, 291, 295, 320, 324, 331, 353, 357.

After replacement, run:
```bash
grep -n "alert(" src/components/cards/CardDetailPage.tsx
```
Expected: 0 results.

**Step 3: Run typecheck**

```bash
npm run typecheck -- --noEmit
```

**Step 4: Commit**

```bash
git add src/components/cards/CardDetailPage.tsx
git commit -m "fix(storefront): replace alert() with toast.error in CardDetailPage"
```

---

## Task 4: Replace remaining alert() calls

**Remaining files:**
1. `src/components/cards/BuySection.tsx` — 2 alert() calls (lines ~61, ~71)
2. `src/app/[locale]/debug/page.tsx` — 1 alert() call (line ~31)
3. Any others found in full scan

**Step 1: Full scan**

```bash
grep -rn "alert(" src/ --include="*.tsx" --include="*.ts" | grep -v "//.*alert("
```

List every remaining result.

**Step 2: Fix BuySection.tsx**

Add `import { toast } from "sonner"` at top.

- Line ~61: `alert('Link copied to clipboard!')` → `toast.success("Link copied")`
- Line ~71: `` alert(`Price alert set for $${targetPrice}`) `` → `` toast.info(`Price alert set — we'll notify you when this drops below $${targetPrice}`) ``

**Step 3: Fix debug/page.tsx**

Add `import { toast } from "sonner"` at top.

- Line ~31: `alert('Incorrect password')` → `toast.error("Incorrect password")`

**Step 4: Fix any remaining files**

Apply same pattern: error states → `toast.error()`, success states → `toast.success()`, informational → `toast.info()`.

**Step 5: Verify zero alert() calls remain**

```bash
grep -rn "alert(" src/ --include="*.tsx" --include="*.ts" | grep -v "//.*alert("
```

Expected: 0 results.

**Step 6: Run typecheck + lint**

```bash
npm run typecheck && npm run lint
```

**Step 7: Commit**

```bash
git add -A
git commit -m "fix(storefront): eliminate all alert() browser dialogs — replace with sonner toasts"
```

---

## Task 5: Build `<RarityBadge>`

**File to create:** `src/components/tcg/RarityBadge.tsx`
**Test file:** `src/components/tcg/__tests__/RarityBadge.test.tsx`

**Step 1: Write the failing test**

Create `src/components/tcg/__tests__/RarityBadge.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { RarityBadge } from '../RarityBadge'

describe('RarityBadge', () => {
  it('renders MTG mythic with visible text label', () => {
    render(<RarityBadge game="MTG" rarity="mythic" />)
    expect(screen.getByText('Mythic Rare')).toBeInTheDocument()
  })

  it('renders MTG rare with correct CSS variable class', () => {
    const { container } = render(<RarityBadge game="MTG" rarity="rare" />)
    // Should use --rarity-mtg-rare token, not arbitrary color
    expect(container.firstChild).toHaveClass('rarity-badge')
  })

  it('renders Pokemon illustration rare', () => {
    render(<RarityBadge game="POKEMON" rarity="illustration" />)
    expect(screen.getByText('Illustration Rare')).toBeInTheDocument()
  })

  it('renders YGO secret rare', () => {
    render(<RarityBadge game="YUGIOH" rarity="secret" />)
    expect(screen.getByText('Secret Rare')).toBeInTheDocument()
  })

  it('renders One Piece leader', () => {
    render(<RarityBadge game="OPTCG" rarity="leader" />)
    expect(screen.getByText('Leader')).toBeInTheDocument()
  })

  it('renders unknown rarity with fallback label', () => {
    render(<RarityBadge game="MTG" rarity="unknown-rarity" />)
    // Should render the raw rarity string, not crash
    expect(screen.getByText('Unknown-rarity')).toBeInTheDocument()
  })

  it('never renders color-only badge (text always visible)', () => {
    render(<RarityBadge game="MTG" rarity="rare" />)
    // aria-label should not be the sole source of text
    const badge = screen.getByText('Rare')
    expect(badge).toBeVisible()
  })
})
```

**Step 2: Run test to verify failure**

```bash
npm run test -- src/components/tcg/__tests__/RarityBadge.test.tsx
```
Expected: FAIL — "Cannot find module '../RarityBadge'"

**Step 3: Create the directory**

```bash
mkdir -p storefront/src/components/tcg/__tests__
```

**Step 4: Implement RarityBadge**

Create `src/components/tcg/RarityBadge.tsx`:

```tsx
import { cn } from "@/lib/utils"

type GameCode = 'MTG' | 'POKEMON' | 'YUGIOH' | 'OPTCG'

interface RarityBadgeProps {
  game: GameCode
  rarity: string
  className?: string
}

// Maps normalized rarity key → { label, cssVar }
const RARITY_CONFIG: Record<GameCode, Record<string, { label: string; cssVar: string }>> = {
  MTG: {
    common:  { label: 'Common',      cssVar: 'var(--rarity-mtg-common)' },
    uncommon:{ label: 'Uncommon',    cssVar: 'var(--rarity-mtg-uncommon)' },
    rare:    { label: 'Rare',        cssVar: 'var(--rarity-mtg-rare)' },
    mythic:  { label: 'Mythic Rare', cssVar: 'var(--rarity-mtg-mythic)' },
  },
  POKEMON: {
    common:       { label: 'Common',            cssVar: 'var(--rarity-poke-common)' },
    uncommon:     { label: 'Uncommon',           cssVar: 'var(--rarity-poke-common)' },
    rare:         { label: 'Rare',               cssVar: 'var(--rarity-poke-common)' },
    ultra:        { label: 'Ultra Rare',          cssVar: 'var(--rarity-poke-ultra)' },
    illustration: { label: 'Illustration Rare',  cssVar: 'var(--rarity-poke-illustration)' },
    hyper:        { label: 'Hyper Rare',          cssVar: 'var(--rarity-poke-hyper)' },
  },
  YUGIOH: {
    common:   { label: 'Common',       cssVar: 'var(--rarity-ygo-common)' },
    rare:     { label: 'Rare',         cssVar: 'var(--rarity-ygo-rare)' },
    super:    { label: 'Super Rare',   cssVar: 'var(--rarity-ygo-super)' },
    ultra:    { label: 'Ultra Rare',   cssVar: 'var(--rarity-ygo-ultra)' },
    secret:   { label: 'Secret Rare', cssVar: 'var(--rarity-ygo-secret)' },
    starlight:{ label: 'Starlight Rare', cssVar: 'var(--rarity-ygo-starlight)' },
  },
  OPTCG: {
    common: { label: 'Common',     cssVar: 'var(--rarity-op-common)' },
    uncommon:{ label: 'Uncommon',  cssVar: 'var(--rarity-op-uncommon)' },
    rare:   { label: 'Rare',       cssVar: 'var(--rarity-op-rare)' },
    super:  { label: 'Super Rare', cssVar: 'var(--rarity-op-super)' },
    secret: { label: 'Secret Rare',cssVar: 'var(--rarity-op-secret)' },
    leader: { label: 'Leader',     cssVar: 'var(--rarity-op-leader)' },
  },
}

function capitalize(s: string) {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

export function RarityBadge({ game, rarity, className }: RarityBadgeProps) {
  const normalized = rarity.toLowerCase().replace(/\s+/g, '')
  const config = RARITY_CONFIG[game]?.[normalized]
  const label = config?.label ?? capitalize(rarity)
  const color = config?.cssVar ?? 'var(--muted-foreground)'

  return (
    <span
      className={cn(
        "rarity-badge inline-flex items-center px-2 py-0.5 rounded text-xs font-medium",
        "border border-current/20",
        className
      )}
      style={{ color, borderColor: `color-mix(in srgb, ${color} 30%, transparent)` }}
      aria-label={`${label} rarity`}
    >
      {label}
    </span>
  )
}
```

**Step 5: Run tests to verify passing**

```bash
npm run test -- src/components/tcg/__tests__/RarityBadge.test.tsx
```
Expected: All 7 tests PASS.

**Step 6: Run typecheck**

```bash
npm run typecheck
```

**Step 7: Commit**

```bash
git add src/components/tcg/RarityBadge.tsx \
        src/components/tcg/__tests__/RarityBadge.test.tsx
git commit -m "feat(storefront): add RarityBadge TCG component"
```

---

## Task 6: Build `<PriceTag>`

**File to create:** `src/components/tcg/PriceTag.tsx`
**Test file:** `src/components/tcg/__tests__/PriceTag.test.tsx`

**Step 1: Write the failing test**

Create `src/components/tcg/__tests__/PriceTag.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { PriceTag } from '../PriceTag'

describe('PriceTag', () => {
  describe('inline variant', () => {
    it('shows price and seller count', () => {
      render(<PriceTag variant="inline" price={15.99} sellerCount={3} />)
      expect(screen.getByText(/\$15\.99/)).toBeInTheDocument()
      expect(screen.getByText(/3 sellers/)).toBeInTheDocument()
    })

    it('shows "No sellers" when price is null', () => {
      render(<PriceTag variant="inline" price={null} />)
      expect(screen.getByText('No sellers')).toBeInTheDocument()
    })
  })

  describe('detailed variant', () => {
    it('shows price, seller count, and market average', () => {
      render(<PriceTag variant="detailed" price={15.99} sellerCount={3} marketAvg={17.50} />)
      expect(screen.getByText(/\$15\.99/)).toBeInTheDocument()
      expect(screen.getByText(/3 sellers/)).toBeInTheDocument()
      expect(screen.getByText(/\$17\.50/)).toBeInTheDocument()
    })

    it('shows downward trend indicator', () => {
      render(<PriceTag variant="detailed" price={15.99} trend="down" />)
      expect(screen.getByLabelText(/price trending down/i)).toBeInTheDocument()
    })

    it('shows upward trend indicator', () => {
      render(<PriceTag variant="detailed" price={15.99} trend="up" />)
      expect(screen.getByLabelText(/price trending up/i)).toBeInTheDocument()
    })
  })

  describe('compact variant', () => {
    it('shows only the price', () => {
      const { container } = render(<PriceTag variant="compact" price={15.99} sellerCount={3} />)
      expect(screen.getByText(/\$15\.99/)).toBeInTheDocument()
      // Should NOT show seller count in compact variant
      expect(container.textContent).not.toContain('sellers')
    })
  })

  describe('accessibility', () => {
    it('has descriptive aria-label', () => {
      render(<PriceTag variant="detailed" price={15.99} sellerCount={3} trend="down" />)
      expect(screen.getByLabelText(/\$15\.99.*3 sellers.*trending down/i)).toBeInTheDocument()
    })
  })
})
```

**Step 2: Run test to verify failure**

```bash
npm run test -- src/components/tcg/__tests__/PriceTag.test.tsx
```
Expected: FAIL — "Cannot find module '../PriceTag'"

**Step 3: Implement PriceTag**

Create `src/components/tcg/PriceTag.tsx`:

```tsx
import { cn } from "@/lib/utils"

type PriceTagVariant = 'inline' | 'detailed' | 'compact'
type TrendDirection = 'up' | 'down' | 'stable'

interface PriceTagProps {
  price: number | null
  sellerCount?: number
  marketAvg?: number
  trend?: TrendDirection
  variant: PriceTagVariant
  className?: string
}

function formatPrice(price: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
  }).format(price)
}

function TrendIcon({ direction }: { direction: TrendDirection }) {
  if (direction === 'stable') return null
  const isDown = direction === 'down'
  return (
    <span
      aria-label={`price trending ${direction}`}
      className={cn('inline-flex items-center', isDown ? 'text-positive' : 'text-warning')}
    >
      {isDown ? '↓' : '↑'}
    </span>
  )
}

export function PriceTag({
  price,
  sellerCount,
  marketAvg,
  trend,
  variant,
  className,
}: PriceTagProps) {
  if (price === null) {
    return (
      <span className={cn('text-muted-foreground text-sm', className)}>
        No sellers
      </span>
    )
  }

  const formattedPrice = formatPrice(price)
  const formattedMarketAvg = marketAvg ? formatPrice(marketAvg) : null

  // Build aria-label
  const ariaLabel = [
    formattedPrice,
    sellerCount ? `${sellerCount} sellers` : null,
    trend && trend !== 'stable' ? `price trending ${trend}` : null,
  ]
    .filter(Boolean)
    .join(', ')

  if (variant === 'compact') {
    return (
      <span
        className={cn('text-sm font-semibold text-[color:var(--text-price)]', className)}
        aria-label={ariaLabel}
      >
        {formattedPrice}
      </span>
    )
  }

  if (variant === 'inline') {
    return (
      <span className={cn('text-sm flex items-center gap-1', className)} aria-label={ariaLabel}>
        <span className="font-semibold text-[color:var(--text-price)]">{formattedPrice}</span>
        {sellerCount !== undefined && sellerCount > 0 && (
          <span className="text-muted-foreground">· {sellerCount} sellers</span>
        )}
        {trend && <TrendIcon direction={trend} />}
      </span>
    )
  }

  // detailed
  return (
    <span
      className={cn('text-sm flex items-center gap-1 flex-wrap', className)}
      aria-label={ariaLabel}
    >
      <span className="font-semibold text-[color:var(--text-price)]">{formattedPrice}</span>
      {sellerCount !== undefined && sellerCount > 0 && (
        <span className="text-muted-foreground">· from {sellerCount} sellers</span>
      )}
      {formattedMarketAvg && (
        <span className="text-muted-foreground">· market avg {formattedMarketAvg}</span>
      )}
      {trend && <TrendIcon direction={trend} />}
    </span>
  )
}
```

**Step 4: Run tests to verify passing**

```bash
npm run test -- src/components/tcg/__tests__/PriceTag.test.tsx
```
Expected: All 8 tests PASS.

**Step 5: Run typecheck**

```bash
npm run typecheck
```

**Step 6: Commit**

```bash
git add src/components/tcg/PriceTag.tsx \
        src/components/tcg/__tests__/PriceTag.test.tsx
git commit -m "feat(storefront): add PriceTag TCG component"
```

---

## Task 7: Build `<CardDisplay>`

**File to create:** `src/components/tcg/CardDisplay.tsx`
**Test file:** `src/components/tcg/__tests__/CardDisplay.test.tsx`

**Context:** `CardDisplay` is the universal card renderer. It absorbs the image loading/retry logic currently in `CardGridItem`. The four variants are: `gallery`, `grid`, `list`, `compact`.

**Step 1: Write the failing test**

Create `src/components/tcg/__tests__/CardDisplay.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { CardDisplay } from '../CardDisplay'
import type { Card } from '@/types/tcg'

// Minimal card fixture
const mockCard: Card = {
  id: 'test-card-1',
  gameId: 'mtg-id',
  gameCode: 'MTG',
  game: { id: 'mtg-id', code: 'MTG', name: 'Magic', displayName: 'Magic: The Gathering', hasColors: true, hasEnergyTypes: false, hasPowerToughness: true, hasLevels: false, etlEnabled: true, createdAt: new Date(), updatedAt: new Date() },
  oracleId: 'oracle-1',
  oracleHash: 'hash-1',
  name: 'Lightning Bolt',
  normalizedName: 'lightning bolt',
}

describe('CardDisplay', () => {
  it('renders card name in grid variant', () => {
    render(<CardDisplay card={mockCard} variant="grid" />)
    expect(screen.getByRole('article')).toBeInTheDocument()
    expect(screen.getByAltText('Lightning Bolt')).toBeInTheDocument()
  })

  it('renders card name in list variant', () => {
    render(<CardDisplay card={mockCard} variant="list" />)
    expect(screen.getByText('Lightning Bolt')).toBeInTheDocument()
  })

  it('renders card name in compact variant', () => {
    render(<CardDisplay card={mockCard} variant="compact" />)
    expect(screen.getByText('Lightning Bolt')).toBeInTheDocument()
  })

  it('applies selected styling when isSelected=true', () => {
    const { container } = render(<CardDisplay card={mockCard} variant="grid" isSelected={true} />)
    // Selected state uses positive border glow
    expect(container.firstChild).toHaveClass('is-selected')
  })

  it('wraps grid variant in a link to card detail page', () => {
    render(<CardDisplay card={mockCard} variant="grid" />)
    const link = screen.getByRole('link')
    expect(link).toHaveAttribute('href', '/cards/test-card-1')
  })

  it('renders fallback when no image URL', () => {
    render(<CardDisplay card={{ ...mockCard, imageUris: undefined }} variant="grid" />)
    // Should render a placeholder, not crash
    expect(screen.getByRole('article')).toBeInTheDocument()
  })
})
```

**Step 2: Run test to verify failure**

```bash
npm run test -- src/components/tcg/__tests__/CardDisplay.test.tsx
```
Expected: FAIL — "Cannot find module '../CardDisplay'"

**Step 3: Implement CardDisplay**

The implementation moves image loading/retry/hover logic from `CardGridItem` into this component. Key imports come from the same utility files `CardGridItem` uses.

Create `src/components/tcg/CardDisplay.tsx`:

```tsx
"use client"

import { useState, useEffect, useRef } from "react"
import Link from "next/link"
import { Card, SearchResult } from "@/types/tcg"
import {
  getCardImageUrl,
  getCardRarity,
  getCardSet,
  getCardBlurhash,
} from "@/lib/data/cards"
import { BlurHashImage } from "@/components/common/BlurHashImage"
import { RarityBadge } from "@/components/tcg/RarityBadge"
import { PriceTag } from "@/components/tcg/PriceTag"
import { cn } from "@/lib/utils"

export type CardDisplayVariant = 'gallery' | 'grid' | 'list' | 'compact'

interface CardDisplayProps {
  card: Card
  searchResult?: SearchResult
  variant: CardDisplayVariant
  price?: number | null
  sellerCount?: number
  priceTrend?: 'up' | 'down' | 'stable'
  isSelected?: boolean
  showSelection?: boolean
  onSelect?: () => void
  onClick?: () => void
  /** Enable drag-and-drop (deck builder usage) */
  draggable?: boolean
  onDragStart?: (e: React.DragEvent) => void
  className?: string
}

type ImageSize = 'normal' | 'small' | 'thumbnail'

function useCardImage(card: Card, componentType: 'grid' | 'compact' | 'gallery') {
  const [imageError, setImageError] = useState(false)
  const [imageLoading, setImageLoading] = useState(true)
  const [retryCount, setRetryCount] = useState(0)
  const [currentSize, setCurrentSize] = useState<ImageSize>('normal')

  const cardId = card.id
  useEffect(() => {
    setImageError(false)
    setImageLoading(true)
    setRetryCount(0)
    setCurrentSize('normal')
  }, [cardId])

  const imageUrl =
    imageError || retryCount > 0
      ? getCardImageUrl(card, currentSize)
      : getCardImageUrl(card, { componentType, prioritizeQuality: false })

  const blurhash = getCardBlurhash(card)

  const handleError = () => {
    if (currentSize === 'normal') {
      setCurrentSize('small')
      setRetryCount((c) => c + 1)
      setImageError(false)
      setImageLoading(true)
    } else if (currentSize === 'small') {
      setCurrentSize('thumbnail')
      setRetryCount((c) => c + 1)
      setImageError(false)
      setImageLoading(true)
    } else {
      setImageError(true)
      setImageLoading(false)
    }
  }

  const handleLoad = () => {
    setImageLoading(false)
    setImageError(false)
  }

  return { imageUrl, blurhash, imageError, imageLoading, handleError, handleLoad }
}

function ImagePlaceholder({ label }: { label: string }) {
  return (
    <div className="w-full h-full bg-muted flex items-center justify-center rounded">
      <span className="text-xs text-muted-foreground">{label}</span>
    </div>
  )
}

function GameBadge({ gameCode }: { gameCode: string }) {
  const colors: Record<string, string> = {
    MTG: 'bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-300',
    POKEMON: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300',
    YUGIOH: 'bg-purple-100 text-purple-800 dark:bg-purple-900/30 dark:text-purple-300',
    OPTCG: 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300',
  }
  return (
    <span className={cn('px-2 py-0.5 text-xs font-medium rounded shadow', colors[gameCode] ?? 'bg-muted text-muted-foreground')}>
      {gameCode}
    </span>
  )
}

export function CardDisplay({
  card,
  searchResult,
  variant,
  price,
  sellerCount,
  priceTrend,
  isSelected = false,
  showSelection = false,
  onSelect,
  onClick,
  draggable = false,
  onDragStart,
  className,
}: CardDisplayProps) {
  const componentType = variant === 'compact' ? 'compact' : variant === 'gallery' ? 'gallery' : 'grid'
  const { imageUrl, blurhash, imageError, handleError, handleLoad } = useCardImage(card, componentType as 'grid' | 'compact' | 'gallery')

  const rarity = getCardRarity(card)
  const gameCode = card.game?.code ?? card.gameCode ?? ''

  const baseProps = {
    role: 'article' as const,
    draggable,
    onDragStart,
    className: cn(isSelected && 'is-selected', className),
  }

  // ---- COMPACT ----
  if (variant === 'compact') {
    return (
      <div
        {...baseProps}
        className={cn(
          'flex items-center gap-2 p-2 rounded bg-card border border-border',
          'hover:border-ring transition-colors cursor-pointer',
          isSelected && 'is-selected border-positive ring-1 ring-positive',
          className
        )}
        onClick={onClick}
      >
        <div className="w-10 h-14 flex-shrink-0 relative rounded overflow-hidden">
          {imageUrl && !imageError ? (
            <BlurHashImage src={imageUrl} alt={card.name} blurhash={blurhash} fill sizes="40px" className="object-contain" onLoad={handleLoad} onError={handleError} />
          ) : (
            <ImagePlaceholder label="?" />
          )}
        </div>
        <span className="text-xs font-medium text-foreground truncate flex-1">{card.name}</span>
      </div>
    )
  }

  // ---- LIST ----
  if (variant === 'list') {
    return (
      <div
        {...baseProps}
        className={cn(
          'flex items-center gap-4 p-4 bg-card rounded-lg border border-border',
          'hover:border-ring hover:shadow-sm transition-all cursor-pointer',
          isSelected && 'is-selected border-positive ring-2 ring-positive/30',
          draggable && 'cursor-grab active:cursor-grabbing',
          className
        )}
        onClick={onClick}
      >
        {showSelection && (
          <input type="checkbox" checked={isSelected} onChange={onSelect} className="w-4 h-4 rounded" />
        )}
        <div className="w-16 h-24 flex-shrink-0 relative">
          {imageUrl && !imageError ? (
            <BlurHashImage src={imageUrl} alt={card.name} blurhash={blurhash} fill sizes="64px" className="object-contain rounded" onLoad={handleLoad} onError={handleError} />
          ) : (
            <ImagePlaceholder label="No Image" />
          )}
        </div>
        <div className="flex-1 min-w-0">
          <Link href={`/cards/${card.id}`} className="block hover:text-primary">
            <h3 className="text-sm font-semibold text-foreground truncate">{card.name}</h3>
          </Link>
          <div className="flex items-center gap-2 mt-1">
            {rarity && gameCode && (
              <RarityBadge game={gameCode as 'MTG' | 'POKEMON' | 'YUGIOH' | 'OPTCG'} rarity={rarity} />
            )}
            {gameCode && <GameBadge gameCode={gameCode} />}
          </div>
          {price !== undefined && (
            <PriceTag variant="inline" price={price ?? null} sellerCount={sellerCount} trend={priceTrend} className="mt-1" />
          )}
        </div>
      </div>
    )
  }

  // ---- GALLERY ----
  if (variant === 'gallery') {
    return (
      <div
        {...baseProps}
        className={cn(
          'group relative rounded-xl overflow-hidden',
          'hover:ring-2 hover:ring-ring transition-all cursor-pointer',
          isSelected && 'is-selected ring-2 ring-positive',
          className
        )}
        onClick={onClick}
      >
        <Link href={`/cards/${card.id}`}>
          <div className="aspect-[5/7] relative">
            {imageUrl && !imageError ? (
              <BlurHashImage src={imageUrl} alt={card.name} blurhash={blurhash} fill sizes="(max-width: 768px) 50vw, 25vw" className="object-contain group-hover:scale-[1.02] transition-transform duration-200" onLoad={handleLoad} onError={handleError} />
            ) : (
              <ImagePlaceholder label="No Image" />
            )}
          </div>
          <div className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/70 to-transparent p-3 translate-y-full group-hover:translate-y-0 transition-transform duration-200">
            <p className="text-white text-sm font-semibold truncate">{card.name}</p>
            {price !== undefined && (
              <PriceTag variant="compact" price={price ?? null} className="text-white/90" />
            )}
          </div>
        </Link>
      </div>
    )
  }

  // ---- GRID (default) ----
  return (
    <div
      {...baseProps}
      className={cn(
        'group relative bg-card rounded-lg border border-border',
        'hover:border-ring hover:shadow-lg hover:-translate-y-0.5 transition-all',
        isSelected && 'is-selected border-positive ring-2 ring-positive/30',
        draggable && 'cursor-grab active:cursor-grabbing',
        className
      )}
      onClick={onClick}
    >
      {showSelection && (
        <div className="absolute top-2 left-2 z-10">
          <input type="checkbox" checked={isSelected} onChange={onSelect} className="w-4 h-4 rounded shadow" />
        </div>
      )}
      <Link href={`/cards/${card.id}`} className="block">
        <div className="aspect-[5/7] relative overflow-hidden rounded-t-lg">
          {imageUrl && !imageError ? (
            <BlurHashImage src={imageUrl} alt={card.name} blurhash={blurhash} fill sizes="(max-width: 640px) 50vw, (max-width: 1024px) 25vw, 20vw" className="object-contain group-hover:scale-[1.02] transition-transform duration-200" onLoad={handleLoad} onError={handleError} priority={false} />
          ) : (
            <ImagePlaceholder label="No Image" />
          )}
          <div className="absolute top-2 right-2">
            <GameBadge gameCode={gameCode} />
          </div>
        </div>
        <div className="p-3 space-y-1">
          <div className="flex items-start justify-between gap-2">
            <h3 className="text-sm font-semibold text-foreground truncate group-hover:text-primary flex-1">
              {card.name}
            </h3>
            {rarity && gameCode && (
              <RarityBadge
                game={gameCode as 'MTG' | 'POKEMON' | 'YUGIOH' | 'OPTCG'}
                rarity={rarity}
                className="flex-shrink-0"
              />
            )}
          </div>
          {price !== undefined ? (
            <PriceTag variant="inline" price={price ?? null} sellerCount={sellerCount} trend={priceTrend} />
          ) : searchResult && (
            <p className="text-xs text-muted-foreground">
              {searchResult.availableListings ?? searchResult.vendorCount ?? 0} listings
            </p>
          )}
        </div>
      </Link>
    </div>
  )
}
```

**Step 4: Run tests**

```bash
npm run test -- src/components/tcg/__tests__/CardDisplay.test.tsx
```
Expected: All 6 tests PASS. (The Link `href` test may need the Next.js mock — if it fails, wrap test with `vi.mock('next/link', () => ({ default: ({ children, href }: any) => <a href={href}>{children}</a> }))` at top of test file.)

**Step 5: Run typecheck**

```bash
npm run typecheck
```

Fix any type errors before proceeding.

**Step 6: Commit**

```bash
git add src/components/tcg/CardDisplay.tsx \
        src/components/tcg/__tests__/CardDisplay.test.tsx
git commit -m "feat(storefront): add CardDisplay universal TCG card renderer"
```

---

## Task 8: Migrate CardGridItem to use CardDisplay internally

**File to modify:** `src/components/cards/CardGridItem.tsx`

**Goal:** Same external API, same behavior. Internally delegates rendering to `<CardDisplay>`. Removes duplicated image logic, rarity badge logic, and game badge logic — which now live in `CardDisplay`.

**Step 1: Write regression test**

Create `src/components/cards/__tests__/CardGridItem.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { CardGridItem } from '../CardGridItem'
import type { Card } from '@/types/tcg'

vi.mock('@/components/tcg/CardDisplay', () => ({
  CardDisplay: ({ card, variant }: { card: Card; variant: string }) => (
    <div data-testid="card-display" data-variant={variant} data-card-id={card.id}>
      {card.name}
    </div>
  ),
}))

const mockCard: Card = {
  id: 'test-1',
  gameId: 'mtg',
  oracleId: 'o1',
  oracleHash: 'h1',
  name: 'Opt',
  normalizedName: 'opt',
}

describe('CardGridItem', () => {
  it('renders in grid mode using CardDisplay grid variant', () => {
    render(<CardGridItem card={mockCard} viewMode="grid" />)
    expect(screen.getByTestId('card-display')).toHaveAttribute('data-variant', 'grid')
  })

  it('renders in list mode using CardDisplay list variant', () => {
    render(<CardGridItem card={mockCard} viewMode="list" />)
    expect(screen.getByTestId('card-display')).toHaveAttribute('data-variant', 'list')
  })

  it('passes isSelected to CardDisplay', () => {
    render(<CardGridItem card={mockCard} isSelected={true} />)
    // CardDisplay should receive isSelected — verify via mock output or prop
    expect(screen.getByTestId('card-display')).toBeInTheDocument()
  })
})
```

**Step 2: Run test to see current state**

```bash
npm run test -- src/components/cards/__tests__/CardGridItem.test.tsx
```
Expected: FAIL (CardGridItem doesn't use CardDisplay yet).

**Step 3: Rewrite CardGridItem to delegate to CardDisplay**

The new `CardGridItem` is much simpler — it handles the hover popup (which still needs `useCardHover`) and drag events, then delegates to `CardDisplay`.

Replace the entire content of `src/components/cards/CardGridItem.tsx` with:

```tsx
"use client"

import { useRef } from "react"
import { Card, SearchResult } from "@/types/tcg"
import { CardDisplay } from "@/components/tcg/CardDisplay"
import { getCardImageUrl } from "@/lib/data/cards"
import { useCardHover } from "./CardHoverProvider"
import { useResponsiveImageSize, useImageSizesAttribute } from "@/contexts/ImageContext"

interface Props {
  card: Card
  searchResult?: SearchResult
  viewMode?: 'grid' | 'list'
  gridColumns?: number
  isSelected?: boolean
  showSelection?: boolean
  onSelect?: () => void
}

export function CardGridItem({
  card,
  searchResult,
  viewMode = 'grid',
  gridColumns = 4,
  isSelected = false,
  showSelection = false,
  onSelect,
}: Props) {
  const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const { showHoverAtPosition, hideHover, isMobile } = useCardHover()

  const canShowHover = viewMode === 'grid' && !isMobile && gridColumns >= 4

  const handleMouseEnter = (e: React.MouseEvent) => {
    if (!canShowHover) return
    if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current)
    const { clientX, clientY } = e
    hoverTimeoutRef.current = setTimeout(() => {
      showHoverAtPosition(card, searchResult, clientX, clientY)
    }, 700)
  }

  const handleMouseLeave = () => {
    if (!canShowHover) return
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current)
      hoverTimeoutRef.current = null
    }
    hideHover()
  }

  const handleDragStart = (e: React.DragEvent) => {
    e.dataTransfer.setData(
      'application/json',
      JSON.stringify({ id: card.id, name: card.name, game: card.game?.code })
    )
    e.dataTransfer.effectAllowed = 'copy'
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current)
      hoverTimeoutRef.current = null
    }
    hideHover()
  }

  return (
    <div
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <CardDisplay
        card={card}
        searchResult={searchResult}
        variant={viewMode === 'list' ? 'list' : 'grid'}
        isSelected={isSelected}
        showSelection={showSelection}
        onSelect={onSelect}
        draggable={true}
        onDragStart={handleDragStart}
      />
    </div>
  )
}
```

**Step 4: Run tests to verify passing**

```bash
npm run test -- src/components/cards/__tests__/CardGridItem.test.tsx
```
Expected: All 3 tests PASS.

**Step 5: Run typecheck**

```bash
npm run typecheck
```

**Step 6: Run full test suite to check for regressions**

```bash
npm run test
```
Expected: All existing tests continue to pass.

**Step 7: Commit**

```bash
git add src/components/cards/CardGridItem.tsx \
        src/components/cards/__tests__/CardGridItem.test.tsx
git commit -m "refactor(storefront): CardGridItem delegates to CardDisplay"
```

---

## Task 9: Migrate ListingCard to use PriceTag and RarityBadge

**File to modify:** `src/components/cards/ListingCard.tsx`

**Goal:** Same external API. Replaces the inline price display with `<PriceTag variant="inline">` and the rarity text with `<RarityBadge>`.

**Step 1: Write regression test**

Create `src/components/cards/__tests__/ListingCard.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { ListingCard } from '../ListingCard'

// Minimal listing fixture
const mockListing = {
  id: 'listing-1',
  price: 15.99,
  seller: 'CardShop',
  seller_type: 'business' as const,
  seller_rating: 99,
  seller_rating_count: 412,
  seller_trust_level: 'verified' as const,
  set_name: 'Dominaria',
  rarity: 'rare',
  condition: 'NM' as const,
  language: 'English',
  stock_quantity: 3,
  last_updated: new Date().toISOString(),
  verified_seller: true,
}

describe('ListingCard', () => {
  it('renders seller name', () => {
    render(<ListingCard listing={mockListing} catalogSku="test-sku" />)
    expect(screen.getByText('CardShop')).toBeInTheDocument()
  })

  it('shows stock quantity', () => {
    render(<ListingCard listing={mockListing} catalogSku="test-sku" />)
    expect(screen.getByText(/3 in stock/)).toBeInTheDocument()
  })

  it('shows "Notify Me" when out of stock', () => {
    render(<ListingCard listing={{ ...mockListing, stock_quantity: 0 }} catalogSku="test-sku" />)
    expect(screen.getByText('Notify Me')).toBeInTheDocument()
  })

  it('calls onAddToCart when Add to Cart is clicked', async () => {
    const onAddToCart = vi.fn()
    render(<ListingCard listing={mockListing} catalogSku="test-sku" onAddToCart={onAddToCart} />)
    screen.getByText('Add to Cart').click()
    expect(onAddToCart).toHaveBeenCalledWith(mockListing, 1)
  })
})
```

**Step 2: Run test to check current baseline**

```bash
npm run test -- src/components/cards/__tests__/ListingCard.test.tsx
```

Expected: Tests PASS (they test behavior, not internal implementation). These are regression tests — they should pass before and after the refactor.

**Step 3: Refactor ListingCard to use PriceTag and RarityBadge**

Modify `src/components/cards/ListingCard.tsx`:

Add imports:
```tsx
import { PriceTag } from "@/components/tcg/PriceTag"
import { RarityBadge } from "@/components/tcg/RarityBadge"
```

Replace the price display block (the `<div className="text-lg font-bold...">` around line 148-155) with:
```tsx
<PriceTag
  variant="inline"
  price={listing.price}
  className="text-right"
/>
{listing.shipping_info && listing.shipping_info.cost > 0 && (
  <div className="text-xs text-muted-foreground mt-0.5">
    +{formatAmount(listing.shipping_info.cost * 100, 'USD')} ship
  </div>
)}
```

Replace the rarity text span (around line 184) with:
```tsx
{listing.rarity && (
  <RarityBadge
    game="MTG"
    rarity={listing.rarity.toLowerCase()}
  />
)}
```

**Note on game detection:** `ListingCard` currently hardcodes `"MTG"` in the game type for `GradingBadge` too. This is a pre-existing limitation — `MarketplaceListing` doesn't include a game field. For Phase 1, use `"MTG"` as default. This will be addressed when `ListingCard` is fully replaced by `SellerRow` in Phase 2.

**Step 4: Run regression tests**

```bash
npm run test -- src/components/cards/__tests__/ListingCard.test.tsx
```
Expected: All 4 tests still PASS.

**Step 5: Run typecheck**

```bash
npm run typecheck
```

**Step 6: Commit**

```bash
git add src/components/cards/ListingCard.tsx \
        src/components/cards/__tests__/ListingCard.test.tsx
git commit -m "refactor(storefront): ListingCard uses PriceTag and RarityBadge"
```

---

## Task 10: Quality gate

**Step 1: Run full lint**

```bash
npm run lint
```
Expected: 0 errors, 0 warnings related to new code.

**Step 2: Run full typecheck**

```bash
npm run typecheck
```
Expected: 0 errors.

**Step 3: Run full test suite with coverage**

```bash
npm run test:coverage
```
Expected: Coverage for `src/components/tcg/` should be >80%. Check the coverage report for `RarityBadge`, `PriceTag`, and `CardDisplay`.

**Step 4: Verify zero browser dialogs**

```bash
grep -rn "alert(\|confirm(\|prompt(" src/ --include="*.tsx" --include="*.ts" | grep -v "//.*\(alert\|confirm\|prompt\)("
```
Expected: 0 results.

**Step 5: Run build**

```bash
npm run build
```
Expected: Build succeeds with 0 errors. (Warnings about bundle size are acceptable.)

**Step 6: Final commit (if any cleanup needed)**

```bash
git add -A
git commit -m "chore(storefront): UX spec phase 1 quality gate — all checks pass"
```

---

## Summary

| Task | Deliverable | Test Strategy |
|---|---|---|
| 1 | shadcn/ui init + 8 Radix components + sonner Toaster | typecheck |
| 2 | confirm()/prompt() → AlertDialog (3 locations) | Canary test + typecheck |
| 3 | 28 alert() → toast in CardDetailPage | grep audit |
| 4 | 7 alert() → toast in remaining files | grep audit |
| 5 | `<RarityBadge>` | 7 unit tests |
| 6 | `<PriceTag>` | 8 unit tests |
| 7 | `<CardDisplay>` (4 variants) | 6 unit tests |
| 8 | CardGridItem refactored | 3 regression tests |
| 9 | ListingCard refactored | 4 regression tests |
| 10 | lint + typecheck + coverage + build | All pass |

<workflow>
  <critical>
    You are an orchestrator running a full multi-agent story lifecycle for SideDecked.

    SESSION-AWARE EXECUTION:
    This workflow spans 3 logical sessions. At each session boundary, save artifacts to disk
    so the next session starts with fresh context. You MAY run all sessions in one conversation
    if context permits, but MUST save artifacts at each boundary regardless.

    SUPERPOWERS INTEGRATION:
    This workflow references Obra Superpowers skills for disciplined engineering practices.
    When a step says "Follow superpowers:X", invoke that skill and follow its protocol exactly.
    Superpowers iron laws override any conflicting instruction in this workflow.

    EVIDENCE-BASED GATES:
    Every phase gate requires FRESH command output as evidence. No claims without running
    verification commands in the current message. Follow superpowers:verification-before-completion.

    FAILURE RECOVERY:
    When any phase encounters failures (test failures, build errors, deployment issues),
    follow superpowers:systematic-debugging before attempting fixes. No random fix attempts.

    GENERAL RULES:
    At each phase, load the specified agent file(s) and fully adopt their persona(s).
    In this orchestrated workflow, apply each loaded agent's domain expertise, principles, and quality rules.
    Do NOT run standalone menu/greeting/wait loops from individual agent files - this workflow controls interaction flow.
    For multi-agent phases, synthesise perspectives distinctly before combining.
    STOP at each phase boundary and wait for {user_name} to confirm before continuing.
    NEVER skip phases. NEVER proceed without explicit user confirmation.
    All file paths use {agent_path} = {project-root}/_bmad/bmm/agents.
  </critical>

  <!-- ═══════════════════════════════════════════════════════════
       SESSION 1: DISCOVERY — Phases 1, 2, 2B, 3
       Goal: Select story, define requirements, produce UX wireframe (UI stories), produce implementation plan
       Artifacts saved: Requirements Brief, UX wireframe HTML (UI stories), Implementation Plan file
       ═══════════════════════════════════════════════════════════ -->

  <!-- ═══════════════════════════════════════════════════════
       PHASE 1: Story Prioritization — SM + PM
       ═══════════════════════════════════════════════════════ -->

  <step n="1" goal="Load SM and PM personas">
    <action>Load and read {agent_path}/sm.md — adopt Bob (Scrum Master) persona completely</action>
    <action>Load and read {agent_path}/pm.md — also embody John (Product Manager) perspective</action>
    <action>Confirm: both agent files loaded, sprint-status and epics already in context</action>
  </step>

  <step n="2" goal="SM+PM: Recommend next story">
    <action>As SM: Review sprint-status.yaml — identify stories in backlog or ready-for-dev state; flag any blockers or dependencies</action>
    <action>As PM: Assess each candidate story against epic priorities and business value</action>
    <action>Jointly recommend the single highest-priority next story with clear justification from both SM and PM viewpoints</action>
    <action>Output a formatted summary:
      - Recommended story key + title
      - Parent epic and its current status
      - Why this story is highest priority (SM: readiness / PM: business value)
      - Any risks or dependencies to be aware of
    </action>
    <ask>
      ## Phase 1 Complete — Story Prioritization

      SM and PM have recommended a story (see above).

      To proceed: type the story key to confirm this recommendation.
      To choose differently: type a different story key.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 2: Requirements + UX — BA + PM + UX Designer
       ═══════════════════════════════════════════════════════ -->

  <step n="3" goal="Load BA, PM, and UX Designer personas">
    <action>Load and read {agent_path}/analyst.md — adopt Mary (Business Analyst) persona</action>
    <action>Load and read {agent_path}/pm.md — retain John (Product Manager) perspective</action>
    <action>Load and read {agent_path}/ux-designer.md — embody UX Designer perspective</action>
    <action>Load the confirmed story file from {story_dir} matching the confirmed story key</action>
    <action>Set {{story_file_path}} to the resolved story file path for downstream validation and documentation steps</action>
  </step>

  <step n="4" goal="BA+PM+UX: Clarify requirements and define UX">
    <action>As BA: Analyse the story's acceptance criteria — identify gaps, ambiguities, missing business rules, and edge cases</action>
    <action>As BA: Produce an AC traceability view (Original AC → Clarified AC → status: clarified/needs-decision) and call out any unresolved requirement conflicts</action>
    <action>As PM: Verify scope is aligned with the parent epic's goals and user personas; flag any scope creep risks</action>
    <action>As UX Designer: For UI-facing criteria only, propose UX flows, interaction patterns, component suggestions, and accessibility considerations</action>
    <action>Output a consolidated Requirements + UX Brief:
      - Clarified acceptance criteria (with any additions or corrections)
      - BA AC traceability and requirement conflict status
      - Business rules and edge cases identified by BA
      - PM scope confirmation or adjustments
      - UX flow notes and interaction patterns (if UI involved)
      - Open questions requiring {user_name} decision (if any)
      - BA sign-off recommendation: READY / BLOCKED with explicit blockers
    </action>
    <ask>
      ## Phase 2 Complete — Requirements and UX Defined

      BA, PM, and UX Designer have produced a Requirements + UX Brief (see above).

      Type CONFIRM to proceed to architecture design.
      Or describe changes needed before continuing.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 2B: UX Wireframe & Validation — UX Designer + Party Mode + Advanced Elicitation
       TRIGGER: Only when story touches storefront/ or vendorpanel/
       Non-UI stories skip Phase 2B and proceed directly to Phase 3.
       ═══════════════════════════════════════════════════════ -->

  <step n="5" goal="UX Designer: Assess UI scope">
    <action>Load and read {agent_path}/ux-designer.md — adopt Sally (UX Designer) persona completely</action>
    <action>Review the confirmed story file and Requirements Brief from Phase 2</action>
    <action>The ux-design-specification.md is already in context via input_file_patterns</action>
    <action>Determine: does this story affect storefront/ or vendorpanel/ UI?
      - Examine the story's acceptance criteria, task list, and affected files for any reference to:
        storefront/, vendorpanel/, pages, components, layouts, screens, user-facing flows, or UI
    </action>
    <check if="story does NOT affect storefront/ or vendorpanel/">
      <action>Output: "No UI scope detected — skipping Phase 2B. Proceeding directly to Phase 3 (Architecture)."</action>
      <action>List the signals that confirmed no UI scope (e.g., story tasks reference only backend/ or customer-backend/)</action>
    </check>
    <check if="story DOES affect storefront/ or vendorpanel/">
      <action>Output the specific screens, flows, and components this story requires:
        - Screen names and their purpose
        - Navigation flows between screens
        - Key components needed (forms, cards, modals, lists, etc.)
        - Interaction patterns (clicks, submissions, state changes)
        - Responsive behavior requirements
      </action>
    </check>
    <ask>
      ## Phase 2B Step 5 — UI Scope Assessment

      UX Designer has assessed the story's UI scope (see above).

      If NO UI scope: type SKIP to bypass Phase 2B and proceed to Phase 3.
      If UI scope confirmed: type CONFIRM to proceed to wireframe generation.
    </ask>
  </step>

  <step n="6" goal="UX Designer: Produce HTML wireframe">
    <action>As UX Designer (Sally):
      - Reference _bmad-output/planning-artifacts/ux-design-directions.html for styling and format conventions
      - Reference ux-design-specification.md for design system, patterns, and interaction principles
      - Produce an HTML wireframe covering:
        * Screen layouts with annotated sections
        * Component hierarchy and nesting
        * Interaction flows between screens (with navigation labels)
        * Responsive behavior notes (mobile vs desktop breakpoints)
        * Hover, focus, and active state annotations
        * Empty states and loading states where relevant
      - The wireframe MUST align with the design system documented in ux-design-specification.md
        (typography, color palette, spacing, component variants, accessibility standards)
    </action>
    <action>Save the wireframe to: _bmad-output/planning-artifacts/ux-{story-key}-wireframe.html</action>
    <ask>
      ## Phase 2B Step 6 — HTML Wireframe Produced

      UX Designer has produced the HTML wireframe and saved it to:
      _bmad-output/planning-artifacts/ux-{story-key}-wireframe.html

      Open the file in a browser to review it.

      Type CONFIRM to proceed to party mode review.
      Or describe wireframe changes needed before the review.
    </ask>
  </step>

  <step n="7" goal="Party Mode: Wireframe review — UX Designer + PM + BA + Architect">
    <critical>
      This is a focused party mode with exactly 5 agents. Do NOT expand to additional agents.
      Each agent reviews the wireframe strictly from their domain perspective.
      The orchestrator synthesises a single Consolidated Wireframe Feedback summary.
    </critical>
    <action>Invoke party mode with the wireframe as the discussion seed.
      Load all five agent perspectives by reading their agent files:
      - {agent_path}/ux-designer.md — Sally (UX Designer)
      - {agent_path}/pm.md — John (Product Manager)
      - {agent_path}/analyst.md — Mary (Business Analyst)
      - {agent_path}/architect.md — Winston (Architect)
      - {agent_path}/dev.md — Amelia (Developer)
    </action>
    <action>As Sally (UX Designer): Review for design system alignment, interaction patterns, accessibility compliance, visual hierarchy, and component reuse</action>
    <action>As John (PM): Review for scope alignment with the epic's goals and user personas; flag any scope creep or missing user journeys</action>
    <action>As Mary (BA): Review for acceptance criteria coverage — does every AC have a corresponding UI element? Are business rules reflected? Any missing edge case screens?</action>
    <action>As Winston (Architect): Review for technical feasibility, component reuse opportunities, data-fetching implications, performance considerations (rendering strategy, lazy loading), and any patterns that would be costly to implement</action>
    <action>As Amelia (Dev): Review implementation feasibility in current codebases (storefront/vendorpanel), likely component breakdown, testing implications, and high-risk UI interactions</action>
    <action>Synthesise a Consolidated Wireframe Feedback summary:
      - Design system alignment: PASS / issues list
      - Scope alignment: PASS / issues list
      - AC coverage: PASS / gaps list
      - Technical feasibility: PASS / concerns list
      - Implementation feasibility: PASS / concerns list
      - Priority of changes: must-fix before architecture / nice-to-have
    </action>
    <ask>
      ## Phase 2B Step 7 — Party Mode Wireframe Review Complete

      UX Designer, PM, BA, Architect, and Dev have reviewed the wireframe (see Consolidated Feedback above).

      Type CONFIRM to proceed to advanced elicitation refinement.
      Or describe specific changes you want incorporated before continuing.
    </ask>
  </step>

  <step n="8" goal="Advanced Elicitation: Refine wireframe">
    <action>Invoke advanced elicitation against the wireframe to surface edge cases, unclear states, and missing flows:
      Apply at minimum the following elicitation angles:
      - "What happens when...?" — error states, timeouts, empty data, permission denied
      - "What does the user expect after...?" — post-action feedback, confirmation messages
      - "What if the user is on mobile?" — touch targets, scroll behaviour, collapsed navigation
      - "What if the data is extreme?" — very long text, zero items, 1000+ items
      - "What are the accessibility requirements?" — keyboard nav, screen reader labels, contrast
    </action>
    <action>As UX Designer (Sally): Incorporate approved changes from party mode feedback and elicitation findings into the wireframe HTML file</action>
    <action>Save the refined wireframe back to: _bmad-output/planning-artifacts/ux-{story-key}-wireframe.html</action>
    <action>Output: final confirmed wireframe path and a summary of all changes made</action>
    <ask>
      ## Phase 2B Complete — UX Wireframe Validated

      Wireframe saved to: _bmad-output/planning-artifacts/ux-{story-key}-wireframe.html

      The wireframe has been reviewed by UX Designer, PM, BA, and Architect via party mode,
      and refined through advanced elicitation.

      Type CONFIRM to proceed to architecture design.
      Or describe further changes needed.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 3: Technical Design + Implementation Plan — Architect
       ═══════════════════════════════════════════════════════ -->

  <step n="9" goal="Load Architect persona">
    <action>Load and read {agent_path}/architect.md — adopt Winston (Architect) persona completely</action>
    <action>Load and read {agent_path}/analyst.md — load Mary (BA) perspective for AC traceability co-review</action>
    <action>Architecture docs are already in context via input_file_patterns</action>
    <action>If Phase 2B produced a wireframe: load _bmad-output/planning-artifacts/ux-{story-key}-wireframe.html as additional context for the technical design</action>
  </step>

  <step n="10" goal="Architect: Design the technical solution">
    <action>As Architect: Review the story, Requirements + UX Brief from Phase 2, and all architecture docs</action>
    <action>If a UX wireframe exists from Phase 2B: incorporate its component hierarchy, interaction flows, and responsive requirements into the technical design</action>
    <action>Enforce split-brain rule — classify this story's domain:
      - Commerce (orders, payments, vendors) → backend/ (mercur-db)
      - Customer Experience (cards, decks, community, pricing) → customer-backend/ (sidedecked-db)
      - Frontend → storefront/ or vendorpanel/
      - NEVER allow direct connection between mercur-db and sidedecked-db
    </action>
    <action>Identify all impacted files and modules</action>
    <action>Specify any new database entities, migrations, or schema changes needed</action>
    <action>Define API contracts for any new or modified endpoints</action>
    <action>Identify integration points with external systems (Stripe, Algolia, Redis, MinIO, Resend)</action>
    <action>As BA (traceability pass): validate the design against every clarified AC and business rule from Phase 2; list any unmapped or partially-mapped ACs as blockers</action>
    <action>Flag architectural risks or decisions requiring {user_name} confirmation</action>
    <action>Determine deployment needs:
      - Sets {{needs_deploy}} = true if story touches storefront/ or vendorpanel/
      - Sets {{needs_deploy}} = true if story adds new API endpoints consumers depend on
      - Sets {{needs_deploy}} = false for backend-only, migration-only, or docs-only changes
    </action>
    <action>Output a Technical Design Note covering:
      - Domain classification and routing
      - Affected files/modules list (with exact paths where possible)
      - New entities/migrations (if any)
      - API contract changes (if any)
      - Integration touchpoints
      - BA traceability status: mapped ACs, unmapped ACs, and required follow-ups
      - Deployment classification: {{needs_deploy}} with justification
      - Wireframe implementation notes (if Phase 2B ran): component strategy, rendering approach
      - Architectural risks or open decisions
    </action>
    <ask>
      ## Phase 3A Complete — Technical Design Ready

      Architect has produced a Technical Design Note (see above).

      Type CONFIRM to proceed to implementation plan.
      Or describe changes needed to the design.
    </ask>
  </step>

  <step n="11" goal="Architect: Write implementation plan to file">
    <critical>Save the plan as a durable artifact — do not rely on conversation context alone</critical>
    <action>Convert the Technical Design Note + Requirements Brief into a structured implementation plan</action>
    <action>Write the plan to: docs/plans/{date}-{story-key}-plan.md</action>
    <action>Set {{plan_file_path}} to the exact saved plan path and reuse this variable in all later phases (including fresh sessions)</action>
    <action>Plan format:
      ```
      # {Story Title} Implementation Plan

      > **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

      **Goal:** {one sentence from story}
      **Story:** {story key} — {story file path}
      **Domain:** {Commerce | Customer Experience | Frontend}
      **Repos:** {list of affected repos}
      **Deployment:** {needs_deploy — true/false with reason}
      **UX Wireframe:** {path to wireframe HTML if Phase 2B ran, otherwise "N/A"}

      ## Requirements Brief (from Phase 2)
      {summarize: clarified ACs, business rules, UX flows}

      ## Technical Design (from Phase 3)
      {summarize: domain routing, entities, API contracts, integration points}

      ---

      ### Task 1: {first implementation task from story}
      **Files:** exact paths to create/modify/test
      **Steps:** TDD cycle — write failing test, verify fail, implement, verify pass, commit

      ### Task 2: ...
      (one task per story task/subtask, in exact story order)
      ```
    </action>
    <action>Commit the plan file: docs({story-scope}): add implementation plan for {story-title}</action>
    <ask>
      ## Phase 3 Complete — Implementation Plan Saved

      Plan written to: {{plan_file_path}}

      **SESSION BOUNDARY RECOMMENDATION:**
      Discovery is complete. For best results, start a fresh session for the Build phase.
      The plan file contains everything the Dev agent needs — no conversation context required.

      To continue in this session: type CONFIRM.
      To start fresh: open a new session and run `/bmad-agent-bmm-dev` with the plan file path.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════════
       SESSION 2: BUILD — Phases 4-5
       Goal: Implement story with TDD, validate with integration tests
       Input: Implementation plan file from Session 1
       Artifacts saved: Code on feature branch, QA report
       ═══════════════════════════════════════════════════════════ -->

  <!-- ═══════════════════════════════════════════════════════
       PHASE 4: Development — Dev (TDD via Superpowers)
       ═══════════════════════════════════════════════════════ -->

  <step n="12" goal="Load Dev persona and prepare workspace">
    <action>Load and read {agent_path}/dev.md — adopt Amelia (Developer) persona completely</action>
    <action>Load the implementation plan file from {{plan_file_path}} when available</action>
    <action>If {{plan_file_path}} is unknown (fresh session), locate the latest matching file in {plan_dir} using pattern *-{story-key}-plan.md, set {{plan_file_path}}, then load it</action>
    <action>Load the story file from {story_dir} matching the story key</action>
    <action>Set {{story_file_path}} to the resolved story file path for Phase 4/5/7 evidence commands</action>
    <action>If starting a fresh session: load the Requirements Brief and Technical Design from the plan file (they are embedded in it)</action>
    <action>If a UX wireframe path is referenced in the plan: load it for component-level implementation guidance</action>
  </step>

  <step n="13" goal="Dev: Create feature branch in root and affected child repos">
    <action>Extract the story key from the confirmed story (e.g., "story-01-1-1" from the story file name)</action>
    <action>Create a feature branch named "feature/{story-key}" from the current branch in the root repo</action>
    <action>Identify which child repos will be modified based on the plan's Repos list:
      - backend/ (independent git repo)
      - customer-backend/ (independent git repo)
      - storefront/ (independent git repo)
      - vendorpanel/ (independent git repo)
    </action>
    <action>For EACH affected child repo, create the same feature branch:
      - cd into the child repo directory
      - git checkout -b feature/{story-key}
      - Confirm branch creation
      - cd back to root
    </action>
    <action>Output:
      - Feature branch name created
      - List of ALL repos where the branch was created (root + child repos)
      - Current git branch confirmation for each repo
    </action>
  </step>

  <step n="14" goal="Dev: Implement story with TDD">
    <critical>
      REQUIRED: Follow superpowers:test-driven-development for EVERY task.
      Iron law: No production code without a failing test first.
      Write code before the test? Delete it. Start over. No exceptions.
    </critical>
    <invoke-workflow config="{project-root}/_bmad/bmm/workflows/4-implementation/dev-story/workflow.yaml" />

    <on-failure>
      Follow superpowers:systematic-debugging:
      1. Read error messages carefully — don't skip past them
      2. Reproduce consistently — can you trigger it reliably?
      3. Check recent changes — what changed that could cause this?
      4. Trace data flow — where does the bad value originate?
      5. Form single hypothesis, test minimally, one variable at a time
      After 3 failed fix attempts: STOP. Question the architecture with {user_name}.
    </on-failure>

    <action>Commit all implementation changes to the feature branch in EACH affected repo:
      - For each repo (root + affected child repos):
        - cd into the repo directory
        - Stage all changed files (code + tests + story file updates)
        - Commit with conventional commit format: feat({story-scope}): implement {story-title}
        - Push to remote: git push -u origin feature/{story-key}
        - Confirm commit hash and push status
        - cd back to root
    </action>

    <!-- EVIDENCE-BASED GATE: superpowers:verification-before-completion -->
    <action>Run verification commands and show FRESH output before claiming completion:
      - backend/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm run test:unit
      - customer-backend/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm test
      - storefront/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm test
      - vendorpanel/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm test
      - Run commands only in repos listed as affected by the implementation plan
      - Run coverage check with the repo-supported command and report changed-area coverage
      - Count (IMPLEMENTED) tags in {{story_file_path}}
      Evidence MUST appear in this message. No claims without fresh output.
    </action>
    <ask>
      ## Phase 4 Complete — Implementation Done

      Dev has implemented the story with TDD on the feature branch.

      **Verification evidence shown above.** Confirm the following:
      - [ ] All quality gates passed (lint, typecheck, build, test) — output shown
      - [ ] Test coverage above 80% on changed modules — output shown
      - [ ] All acceptance criteria marked (IMPLEMENTED) in the story file
      - [ ] Changes committed and pushed to feature branch

      Type CONFIRM to proceed to integration testing.
      Or describe issues to fix first.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 5: Integration + E2E Testing — QA
       (Refocused: Phase 4 handles unit TDD. Phase 5 handles
        cross-service integration and user-flow E2E tests.)
       ═══════════════════════════════════════════════════════ -->

  <step n="15" goal="Load QA persona">
    <action>Load and read {agent_path}/qa.md — adopt Quinn (QA) persona completely</action>
  </step>

  <step n="16" goal="QA: Integration and E2E test validation">
    <critical>
      Phase 4 already validated unit tests and coverage via TDD.
      Phase 5 focuses on what unit tests CANNOT cover:
      - Cross-service API contract validation
      - Integration tests across repo boundaries
      - E2E user flow tests for UI-facing stories
      - Edge cases at system boundaries (auth, payments, external APIs)
      If the story is purely internal with no cross-service or UI impact,
      Phase 5 may confirm "no additional integration testing needed" with justification.
    </critical>

    <action>Invoke BMM QA skill bmad-bmm-qa-generate-e2e-tests to generate/extend E2E test candidates for this story before finalizing test scope</action>
    <action>For high-risk cross-service or auth/payment flows, invoke TEA skills for deeper rigor:
      - bmad-tea-testarch-test-design
      - bmad-tea-testarch-automate
      - bmad-tea-testarch-trace
    </action>
    <action>Review the implementation plan's domain classification and integration touchpoints</action>
    <action>Identify cross-service boundaries this story touches:
      - Does backend/ expose APIs that storefront/ or vendorpanel/ consume?
      - Does customer-backend/ interact with backend/ via API?
      - Are there external service integrations (Stripe, Algolia, Redis)?
    </action>

    <check if="story has cross-service or UI impact">
      <action>Write integration tests for cross-service API contracts</action>
      <action>Write E2E tests for critical user flows (if UI involved)</action>
      <action>Test edge cases at system boundaries (auth tokens, error responses, timeouts)</action>
      <action>Run integration/E2E test suite and report results</action>
    </check>

    <check if="story is internal with no cross-service impact">
      <action>Document justification: "No additional integration testing needed because {reason}"</action>
      <action>Verify Phase 4 unit test coverage is comprehensive for this story's scope</action>
    </check>

    <action>Commit any QA-related changes to the feature branch:
      - Stage any new or modified test files and fixes
      - If there are changes: commit with format test({story-scope}): add integration test coverage for {story-title}
      - Push to remote: git push
      - If no changes: skip commit (report "no additional changes from QA")
    </action>

    <!-- EVIDENCE-BASED GATE -->
    <action>Run full quality gate in each affected repo and show FRESH output:
      - backend/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm run test:unit
      - customer-backend/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm test
      - storefront/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm test
      - vendorpanel/: npm run lint &amp;&amp; npm run typecheck &amp;&amp; npm run build &amp;&amp; npm test
      - Run commands only in repos listed as affected by the implementation plan
    </action>
    <action>Output a QA Report:
      - Integration tests added/verified (or justification for skipping)
      - E2E tests added/verified (or justification for skipping)
      - Full quality gate results with output shown
      - Coverage percentage per changed module
    </action>
    <ask>
      ## Phase 5 Complete — Integration Testing Done

      Quinn has produced a QA Report (see above).

      **SESSION BOUNDARY RECOMMENDATION:**
      Build is complete. For best results, start a fresh session for the Ship phase.
      All code is committed to the feature branch — no conversation context required.

      To continue in this session: type CONFIRM.
      To start fresh: open a new session and proceed to documentation/deployment.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════════
       SESSION 3: SHIP — Phases 6-8
       Goal: Deploy, document, review, merge
       Input: Feature branch with all code committed
       ═══════════════════════════════════════════════════════════ -->

  <!-- ═══════════════════════════════════════════════════════
       PHASE 6: Deployment — DevOps (CONDITIONAL)
       Only runs if {{needs_deploy}} == true
       ═══════════════════════════════════════════════════════ -->

  <step n="17" goal="Check if production deployment is needed">
    <action>Read {{plan_file_path}} to retrieve {{needs_deploy}} value</action>
    <action>Re-validate {{needs_deploy}} using actual changed repos/files on the feature branch; if actual changes contradict the plan classification, update the effective deployment decision and explain why</action>
    <action>If {{plan_file_path}} is unknown, ask {user_name} for the exact path before continuing</action>
    <check if="needs_deploy == false">
      <action>Output: "Phase 6 SKIPPED — Production deployment not needed for this story.
        Reason: {justification from plan file}
        Proceeding directly to documentation."
      </action>
      <ask>
        ## Phase 6 Skipped — No Deployment Needed

        This story does not require a Railway production deployment.
        Reason: {justification}

        Type CONFIRM to proceed to documentation.
        Or type DEPLOY to override and deploy anyway.
      </ask>
    </check>
  </step>

  <step n="18" goal="DevOps: Deploy to Railway production">
    <check if="needs_deploy == true OR user typed DEPLOY">
      <action>Load and read {agent_path}/devops.md — adopt Rex (DevOps Automation Engineer) persona completely</action>
      <action>Verify Railway CLI is installed (railway --version); if not, instruct {user_name} to install it</action>
      <action>Ensure the feature branch is pushed and up to date in every repo selected for deployment</action>
      <action>Identify which services are affected by the story changes</action>
      <action>For EACH affected deployable child repo (backend/, customer-backend/, storefront/, vendorpanel/):
        - cd into that repo
        - Deploy using: railway up --detach
        - Monitor logs using: railway logs
        - cd back to root
      </action>

      <on-failure>
        Follow superpowers:systematic-debugging for deployment failures:
        1. Read deployment error messages and logs completely
        2. Check environment variables, build settings, runtime config
        3. Compare with working deployments — what is different?
        4. Fix root cause, not symptoms. One change at a time.
      </on-failure>

      <action>Once deployed successfully:
        - For EACH deployed child repo, get service URL/status using: railway status (from inside that repo)
        - Test critical paths to verify the feature works in production
        - Document production URLs per deployed service
      </action>
      <action>Output a Deployment Report:
        - Railway production URL
        - Services deployed
        - Deployment status (success/failure)
        - Any issues encountered and how they were resolved
        - Basic smoke test results
      </action>
      <ask>
        ## Phase 6 Complete — Production Deployment Verified

        Rex (DevOps) has deployed the feature to Railway production (see above).

        Before confirming, verify:
        - [ ] Production environment is accessible
        - [ ] Feature works as expected in production
        - [ ] No critical errors in Railway logs

        Type CONFIRM to proceed to documentation.
        Or describe deployment issues to fix.
      </ask>
    </check>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 7: Documentation — Tech Writer
       ═══════════════════════════════════════════════════════ -->

  <step n="19" goal="Load Tech Writer persona with full documentation context">
    <action>Load and read {agent_path}/tech-writer/tech-writer.md — adopt Tech Writer persona completely</action>
    <action>Load and read {project-root}/_bmad/_memory/tech-writer-sidecar/documentation-standards.md — quality rules for ALL documentation</action>
    <action>Load and read {project-root}/_bmad/_config/agents/bmm-tech-writer.customize.yaml — SideDecked-specific rules</action>
    <action>If {{plan_file_path}} is unknown, ask {user_name} for the exact path before loading Tech Writer context</action>
    <action>Load {{plan_file_path}} to recover Phase 2 + Phase 3 context:
      - Requirements Brief: key user-facing features, business rules, UX flows
      - Technical Design: domain classification, affected files/modules, new entities, API contracts
    </action>
    <action>Confirm: Tech Writer persona loaded, documentation standards primed, plan context recovered</action>
  </step>

  <step n="20" goal="Tech Writer: Execute documentation sub-workflow">
    <action>Load and read {agent_path}/analyst.md and use BA perspective to verify business-rule and acceptance-criteria wording consistency in docs</action>
    <action>Update CHANGELOG.md with a concise entry for this story (what changed and why)</action>
    <action>Update architecture docs when architecture, integration contracts, or operational behavior changed; otherwise document why no architecture update was needed</action>
    <action>Update {{story_file_path}} so implemented acceptance criteria are marked (IMPLEMENTED)</action>
    <action>Update {sprint_status} so the story status is set to done</action>
    <action>Commit documentation changes to the feature branch:
      - Stage docs and tracking updates
      - If there are changes: commit with format docs({story-scope}): document {story-title} and push
      - If no changes: explicitly report no-op with rationale
    </action>
    <action>Output a Documentation Update Report listing files changed, rationale, and any intentionally skipped docs</action>

    <!-- EVIDENCE-BASED GATE -->
    <action>Show evidence of documentation updates:
      - List all doc files changed (git diff --name-only on docs/)
      - Show CHANGELOG.md entry added
      - Show story file AC status tags
    </action>
    <ask>
      ## Phase 7A Complete — Documentation Updated

      Tech Writer has applied documentation updates (see Documentation Update Report above).

      Before confirming, verify the evidence shown above:
      - [ ] CHANGELOG.md has a substantive entry (what + why)
      - [ ] Architecture docs addressed (updated or justified)
      - [ ] Story acceptance criteria verified and marked (IMPLEMENTED)
      - [ ] New docs created where warranted (API, architecture, user guide)
      - [ ] All changes committed and pushed to feature branch

      Type CONFIRM to proceed to pull request creation.
      Or describe documentation gaps to address first.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 8: Pull Request Creation + Two-Stage Code Review
       ═══════════════════════════════════════════════════════ -->

  <step n="21" goal="Create pull requests in ALL repos with commits">
    <action>Ensure all changes are committed and pushed to the feature branch in every affected repo</action>
    <action>For EACH repo that received commits (root + any child repos):
      - cd into the repo directory
      - Check if the feature branch has commits ahead of main: git log main..HEAD --oneline
      - If there ARE commits: create a PR using gh CLI
        - PR title: concise and descriptive, matching the story title
        - PR body must include:
          - Story key reference
          - Summary of changes specific to this repo
          - **Documentation Changes** section listing docs updated or created
          - **UX Wireframe** reference (if Phase 2B ran): _bmad-output/planning-artifacts/ux-{story-key}-wireframe.html
          - Railway production URL (if Phase 6 ran)
          - Testing notes (unit + integration coverage)
          - Acceptance criteria checklist
        - Do NOT use AI references in PR title or body
      - If there are NO commits: skip — do NOT create an empty PR
      - cd back to root
    </action>
    <action>Validate: for each PR created, verify documentation files appear in the PR diff</action>
    <action>Output a PR Creation Summary table:
      | Repo | Had commits? | PR created? | PR URL | Doc files in diff? |
    </action>
    <ask>
      ## Phase 8A Complete — Pull Requests Created

      PRs have been created for all repos with commits (see table above).

      Type CONFIRM to proceed to code review.
      Or describe any changes needed to the PRs.
    </ask>
  </step>

  <step n="22" goal="Two-stage code review using explicit BMM review skills">
    <critical>
      REPLACED: Single-agent adversarial self-review.
      NEW: Two-stage review using bmad-bmm-code-review skill with two explicit passes.

      Stage 1 — Spec Compliance Review (bmad-bmm-code-review):
        Does the code match the story's acceptance criteria exactly?
        Nothing extra (YAGNI), nothing missing.
        BA perspective is mandatory for AC interpretation disputes.

      Stage 2 — Code Quality Review (bmad-bmm-code-review):
        Clean code, security, performance, architecture compliance, test quality.

      Use a fresh reviewer context for each pass to avoid implementer bias.

      For handling human PR comments later, follow superpowers:receiving-code-review:
        Verify before implementing. Push back with technical reasoning if wrong.
        No performative agreement.
    </critical>

    <!-- Stage 1: Spec Compliance -->
    <action>Invoke bmad-bmm-code-review for spec compliance review:
      - Provide: story file path, implementation plan path, list of PRs with URLs
      - Review focus: acceptance-criteria traceability and YAGNI compliance
      - Include BA perspective to adjudicate requirement interpretation
      - Output: PASS (all ACs met) or FAIL (list exact gaps with file:line evidence)
    </action>

    <check if="spec compliance fails">
      <action>Fix the spec gaps identified by the reviewer</action>
      <action>Run quality gates, commit, push</action>
      <action>Re-run bmad-bmm-code-review spec compliance pass to verify fixes</action>
      <action>Repeat until spec compliance passes</action>
    </check>

    <!-- Stage 2: Code Quality -->
    <action>Invoke bmad-bmm-code-review for code quality review in a fresh reviewer context:
      - Provide: story file path, PR URLs, base and head SHAs
      - Review focus: code quality, security, performance, architecture compliance, test quality
      - Output: APPROVED or list of issues (Critical/Important/Minor) with file:line evidence
    </action>

    <check if="code quality review has Critical or Important issues">
      <action>Fix Critical issues immediately</action>
      <action>Fix Important issues before proceeding</action>
      <action>Note Minor issues (fix if quick, skip if not)</action>
      <action>Run quality gates, commit, push</action>
      <action>Re-run bmad-bmm-code-review code quality pass to verify fixes</action>
    </check>

    <action>Output a combined Code Review Report:
      - Spec compliance: PASS/FAIL with details
      - Code quality: APPROVED/ISSUES with severity breakdown
      - Issues fixed during review
      - Final quality gate evidence (run and show output)
    </action>
    <ask>
      ## Phase 8B Complete — Code Review Done

      Two-stage code review complete (see report above).

      Type CONFIRM to proceed to PR handling and merge.
      Or describe additional review concerns.
    </ask>
  </step>

  <step n="23" goal="Handle PR comments and merge">
    <critical>
      For human PR comments, follow superpowers:receiving-code-review:
      - READ complete feedback without reacting
      - VERIFY against codebase reality before implementing
      - EVALUATE: technically sound for THIS codebase?
      - Push back with technical reasoning if suggestion is wrong
      - No performative agreement ("Great point!", "You're right!")
      - Fix one item at a time, test each
    </critical>

    <action>For EACH open PR, check for human reviewer comments:
      - Run: gh pr view {pr_number} --comments --json comments,reviewComments,reviews
      - If unresolved comments exist: address them per superpowers:receiving-code-review
      - For CHANGE_REQUEST: verify suggestion is correct, fix code, run quality gate, commit, push, respond, resolve
      - For QUESTION: answer factually, resolve
      - For SUGGESTION: evaluate for scope (YAGNI check), implement or decline with explanation, resolve
    </action>

    <check if="no human comments or all resolved">
      <action>For EACH PR with all threads resolved:
        - Post merge summary comment
        - Merge PR: gh pr merge {pr_number} --squash --delete-branch
        - Confirm merge success and record merge commit SHA
      </action>
    </check>

    <check if="unresolved threads remain after addressing">
      <action>Report the specific unresolved threads and which reviewer must take action</action>
      <action>Do NOT force-merge — surface the blocker to {user_name}</action>
    </check>

    <action>Output a Merge Summary table:
      | Repo | PR | Merged? | Merge Commit | Notes |
    </action>
    <ask>
      ## Phase 8 Complete — PRs Merged

      All PR comments addressed and PRs merged (see table above).

      Type CONFIRM to finalize the story lifecycle.
      Or describe any remaining issues.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       COMPLETE
       ═══════════════════════════════════════════════════════ -->

  <step n="24" goal="Story lifecycle complete">
    <action>Output a final Lifecycle Summary:
      - Story key and title
      - All phases completed with brief status per phase (note any skipped phases)
      - Phase 2B: wireframe path (or "skipped — no UI scope")
      - Feature branch name
      - Railway production URL (if deployed)
      - Pull requests created and merged: repo | PR number | PR URL | Merge status
      - Total files changed (across all repos)
      - Final test coverage achieved
      - Total PR comments resolved
      - Plan file location: {{plan_file_path}}
    </action>
    <action>Remind {user_name}: All PRs have been reviewed, comment-resolved, and merged to main</action>
  </step>

</workflow>

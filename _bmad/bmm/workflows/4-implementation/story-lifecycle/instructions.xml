<workflow>
  <critical>
    You are an orchestrator running a full multi-agent story lifecycle for SideDecked.
    At each phase, load the specified agent file(s) and fully adopt their persona(s).
    For multi-agent phases, synthesise perspectives from all loaded agents — present
    their viewpoints distinctly before producing a combined recommendation.
    STOP at each phase boundary and wait for {user_name} to confirm before continuing.
    NEVER skip phases. NEVER proceed without explicit user confirmation.
    All file paths use {agent_path} = {project-root}/_bmad/bmm/agents.
  </critical>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 1: Story Prioritization — SM + PM
       ═══════════════════════════════════════════════════════ -->

  <step n="1" goal="Load SM and PM personas">
    <action>Load and read {agent_path}/sm.md — adopt Bob (Scrum Master) persona completely</action>
    <action>Load and read {agent_path}/pm.md — also embody John (Product Manager) perspective</action>
    <action>Confirm: both agent files loaded, sprint-status and epics already in context</action>
  </step>

  <step n="2" goal="SM+PM: Recommend next story">
    <action>As SM: Review sprint-status.yaml — identify stories in backlog or ready-for-dev state; flag any blockers or dependencies</action>
    <action>As PM: Assess each candidate story against epic priorities and business value</action>
    <action>Jointly recommend the single highest-priority next story with clear justification from both SM and PM viewpoints</action>
    <action>Output a formatted summary:
      - Recommended story key + title
      - Parent epic and its current status
      - Why this story is highest priority (SM: readiness / PM: business value)
      - Any risks or dependencies to be aware of
    </action>
    <ask>
      ## Phase 1 Complete — Story Prioritization

      SM and PM have recommended a story (see above).

      To proceed: type the story key to confirm this recommendation.
      To choose differently: type a different story key.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 2: Requirements + UX — BA + PM + UX Designer
       ═══════════════════════════════════════════════════════ -->

  <step n="3" goal="Load BA, PM, and UX Designer personas">
    <action>Load and read {agent_path}/analyst.md — adopt Mary (Business Analyst) persona</action>
    <action>Load and read {agent_path}/pm.md — retain John (Product Manager) perspective</action>
    <action>Load and read {agent_path}/ux-designer.md — embody UX Designer perspective</action>
    <action>Load the confirmed story file from {story_dir} matching the confirmed story key</action>
  </step>

  <step n="4" goal="BA+PM+UX: Clarify requirements and define UX">
    <action>As BA: Analyse the story's acceptance criteria — identify gaps, ambiguities, missing business rules, and edge cases</action>
    <action>As PM: Verify scope is aligned with the parent epic's goals and user personas; flag any scope creep risks</action>
    <action>As UX Designer: For any UI-facing criteria, propose UX flows, interaction patterns, component suggestions, and accessibility considerations</action>
    <action>Output a consolidated Requirements + UX Brief:
      - Clarified acceptance criteria (with any additions or corrections)
      - Business rules and edge cases identified by BA
      - PM scope confirmation or adjustments
      - UX flow notes and interaction patterns (if UI involved)
      - Open questions requiring {user_name} decision (if any)
    </action>
    <ask>
      ## Phase 2 Complete — Requirements and UX Defined

      BA, PM, and UX Designer have produced a Requirements + UX Brief (see above).

      Type CONFIRM to proceed to architecture design.
      Or describe changes needed before continuing.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 3: Technical Design — Architect
       ═══════════════════════════════════════════════════════ -->

  <step n="5" goal="Load Architect persona">
    <action>Load and read {agent_path}/architect.md — adopt Winston (Architect) persona completely</action>
    <action>Architecture docs are already in context via input_file_patterns</action>
  </step>

  <step n="6" goal="Architect: Design the technical solution">
    <action>As Architect: Review the story, Requirements + UX Brief from Phase 2, and all architecture docs</action>
    <action>Enforce split-brain rule — classify this story's domain:
      - Commerce (orders, payments, vendors) → backend/ (mercur-db)
      - Customer Experience (cards, decks, community, pricing) → customer-backend/ (sidedecked-db)
      - Frontend → storefront/ or vendorpanel/
      - NEVER allow direct connection between mercur-db and sidedecked-db
    </action>
    <action>Identify all impacted files and modules</action>
    <action>Specify any new database entities, migrations, or schema changes needed</action>
    <action>Define API contracts for any new or modified endpoints</action>
    <action>Identify integration points with external systems (Stripe, Algolia, Redis, MinIO, Resend)</action>
    <action>Flag architectural risks or decisions requiring {user_name} confirmation</action>
    <action>Output a Technical Design Note:
      - Domain classification and routing
      - Affected files/modules list
      - New entities/migrations (if any)
      - API contract changes (if any)
      - Integration touchpoints
      - Architectural risks or open decisions
    </action>
    <ask>
      ## Phase 3 Complete — Technical Design Ready

      Architect has produced a Technical Design Note (see above).

      Type CONFIRM to proceed to development.
      Or describe changes needed to the design.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 4: Development — Dev (TDD)
       ═══════════════════════════════════════════════════════ -->

  <step n="7" goal="Load Dev persona and execute story">
    <action>Load and read {agent_path}/dev.md — adopt Amelia (Developer) persona completely</action>
    <action>Context already contains: story file, Requirements + UX Brief, Technical Design Note</action>
  </step>

  <step n="8" goal="Dev: Create feature branch in root and affected child repos">
    <action>Extract the story key from the confirmed story (e.g., "story-01-1-1" from the story file name)</action>
    <action>Create a feature branch named "feature/{story-key}" from the current branch in the root repo</action>
    <action>Identify which child repos will be modified based on the Technical Design Note from Phase 3:
      - backend/ (independent git repo)
      - customer-backend/ (independent git repo)
      - storefront/ (independent git repo)
      - vendorpanel/ (independent git repo)
    </action>
    <action>For EACH affected child repo, create the same feature branch:
      - cd into the child repo directory
      - git checkout -b feature/{story-key}
      - Confirm branch creation
      - cd back to root
    </action>
    <action>Output:
      - Feature branch name created
      - List of ALL repos where the branch was created (root + child repos)
      - Current git branch confirmation for each repo
    </action>
  </step>

  <step n="9" goal="Dev: Implement story with TDD">
    <invoke-workflow config="{project-root}/_bmad/bmm/workflows/4-implementation/dev-story/workflow.yaml" />
    <action>Commit all implementation changes to the feature branch in EACH affected repo:
      - For each repo (root + affected child repos):
        - cd into the repo directory
        - Stage all changed files (code + tests + story file updates)
        - Commit with conventional commit format: feat({story-scope}): implement {story-title}
        - Push to remote: git push -u origin feature/{story-key}
        - Confirm commit hash and push status
        - cd back to root
    </action>
    <ask>
      ## Phase 4 Complete — Implementation Done

      Dev has implemented the story and unit tests on feature branch.

      Before confirming, verify:
      - [ ] All acceptance criteria marked (IMPLEMENTED) in the story file
      - [ ] Quality gate passed: npm run lint and npm run typecheck and npm run build and npm test
      - [ ] Test coverage above 80% on changed modules
      - [ ] Changes committed and pushed to feature branch

      Type CONFIRM to proceed to QA.
      Or describe issues to fix first.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 5: Quality Assurance — QA
       ═══════════════════════════════════════════════════════ -->

  <step n="10" goal="Load QA persona">
    <action>Load and read {agent_path}/qa.md — adopt Quinn (QA) persona completely</action>
  </step>

  <step n="11" goal="QA: Validate tests and coverage">
    <invoke-workflow config="{project-root}/_bmad/bmm/workflows/qa/automate/workflow.yaml" />
    <action>Verify test coverage is above 80% on all changed modules</action>
    <action>Confirm all quality gates pass in the affected repo(s)</action>
    <action>Report any failures with specific file and line references</action>
    <action>Output a QA Report:
      - Quality gate results (lint / typecheck / build / test)
      - Coverage percentage per changed module
      - Any failures or gaps found
    </action>
    <action>Commit any QA-related changes to the feature branch:
      - Stage any new or modified test files and fixes
      - If there are changes: commit with format test({story-scope}): add QA test coverage for {story-title}
      - Push to remote: git push
      - If no changes: skip commit (report "no additional changes from QA")
    </action>
    <ask>
      ## Phase 5 Complete — QA Validated

      Quinn has run tests and produced a QA Report (see above).

      Type CONFIRM to proceed to deployment.
      Or describe issues to fix before deploying.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 6: Deployment — DevOps (Railway Preview)
       ═══════════════════════════════════════════════════════ -->

  <step n="12" goal="Load DevOps persona">
    <action>Load and read {agent_path}/devops.md — adopt Rex (DevOps Automation Engineer) persona completely</action>
  </step>

  <step n="13" goal="DevOps: Deploy feature branch to Railway preview">
    <action>Verify Railway CLI is installed (railway --version); if not, instruct {user_name} to install it</action>
    <action>Ensure the feature branch is pushed to remote: git push -u origin feature/{story-key}</action>
    <action>Identify which services are affected by the story changes (backend, customer-backend, storefront, vendorpanel)</action>
    <action>Deploy affected services to Railway preview environment using: railway up --detach</action>
    <action>Monitor deployment logs for errors using: railway logs</action>
    <action>If deployment fails:
      - Analyze error messages and logs
      - Fix configuration issues (environment variables, build settings, etc.)
      - Fix code issues if deployment reveals runtime errors
      - Re-deploy and verify
      - Repeat until deployment succeeds
    </action>
    <action>Once deployed successfully:
      - Get the preview URL using: railway status
      - Test critical paths to verify the feature works in the preview environment
      - Document the preview URL
    </action>
    <action>Commit any deployment configuration fixes to the feature branch:
      - Stage any config or code changes made to fix deployment issues
      - If there are changes: commit with format fix({story-scope}): resolve deployment issues for {story-title}
      - Push to remote: git push
      - If no changes: skip commit (report "no deployment fixes needed")
    </action>
    <action>Output a Deployment Report:
      - Railway preview URL
      - Services deployed
      - Deployment status (success/failure)
      - Any issues encountered and how they were resolved
      - Basic smoke test results
    </action>
    <ask>
      ## Phase 6 Complete — Deployment to Preview Verified

      Rex (DevOps) has deployed the feature to Railway preview (see above).

      Before confirming, verify:
      - [ ] Preview environment is accessible
      - [ ] Feature works as expected in preview
      - [ ] No critical errors in Railway logs

      Type CONFIRM to proceed to documentation.
      Or describe deployment issues to fix.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 7: Documentation — Tech Writer
       ═══════════════════════════════════════════════════════ -->

  <step n="14" goal="Load Tech Writer persona with full documentation context">
    <action>Load and read {agent_path}/tech-writer/tech-writer.md — adopt Tech Writer persona completely</action>
    <action>Load and read {project-root}/_bmad/_memory/tech-writer-sidecar/documentation-standards.md — these are the quality rules for ALL documentation output</action>
    <action>Load and read {project-root}/_bmad/_config/agents/bmm-tech-writer.customize.yaml — SideDecked-specific tech writer rules</action>
    <action>Summarize the Phase 2 outputs already in context:
      - Requirements + UX Brief: list the key user-facing features, business rules, and UX flows defined
      - These inform which user guides and feature docs may need creating
    </action>
    <action>Summarize the Phase 3 outputs already in context:
      - Technical Design Note: list the domain classification, affected files/modules, new entities, API contracts, integration points
      - These inform which architecture docs, API docs, and READMEs need updating
    </action>
    <action>Confirm: Tech Writer persona loaded, documentation standards primed, Phase 2 + Phase 3 context summarized and ready as primary inputs for documentation work</action>
  </step>

  <step n="15" goal="Tech Writer: Execute documentation sub-workflow">
    <invoke-workflow config="{project-root}/_bmad/bmm/workflows/4-implementation/story-docs/workflow.yaml" />
    <ask>
      ## Phase 7A Complete — Documentation Updated

      Tech Writer has executed the documentation workflow (see Documentation Update Report above).

      Before confirming, verify:
      - [ ] CHANGELOG.md has a substantive entry (what + why)
      - [ ] Architecture docs addressed (updated or justified)
      - [ ] Story acceptance criteria verified and marked (IMPLEMENTED)
      - [ ] New docs created where warranted (API, architecture, user guide)
      - [ ] All changes committed and pushed to feature branch

      Type CONFIRM to proceed to pull request creation.
      Or describe documentation gaps to address first.
    </ask>
  </step>

  <step n="16" goal="Tech Writer: Create pull requests in ALL repos that received commits">
    <action>Ensure all changes are committed and pushed to the feature branch in every affected repo</action>
    <action>For EACH repo that received commits during Phase 4 (root + any child repos):
      - cd into the repo directory
      - Check if the feature branch has commits ahead of main: git log main..HEAD --oneline
      - If there ARE commits: create a PR using gh CLI
        - PR title: concise and descriptive, matching the story title
        - PR body must include:
          - Story key reference
          - Summary of changes specific to this repo
          - **Documentation Changes** section listing docs updated or created in this repo (from the Documentation Update Report in Step 15)
          - Railway preview URL from deployment phase
          - Testing notes
          - Acceptance criteria checklist
        - Do NOT use AI references in PR title or body
      - If there are NO commits (branch was created but empty): skip — do NOT create an empty PR
      - cd back to root
    </action>
    <action>Validate: for each PR created, verify that documentation files from the Documentation Update Report appear in the PR diff. If any doc file is missing, investigate before finalizing the PR.</action>
    <action>Output a PR Creation Summary table listing all repos:
      | Repo | Had commits? | PR created? | PR URL | Doc files in diff? |
      (one row per repo — root + all child repos with feature branches)
    </action>
    <ask>
      ## Phase 7 Complete — Pull Requests Created

      Pull requests have been created for all repos with commits (see table above).

      Type CONFIRM to proceed to code review and PR comment handling.
      Or describe any changes needed to the PRs.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       PHASE 8: Code Review + PR Comment Resolution — Code Reviewer
       ═══════════════════════════════════════════════════════ -->

  <step n="17" goal="Load Code Reviewer persona">
    <action>Load and read {agent_path}/dev.md — adopt Amelia (Developer) persona in adversarial code reviewer mode</action>
    <action>Context already contains: story file, all phase outputs, PR URLs from Phase 7</action>
    <action>Confirm: feature branch name is "feature/{{story_key}}" and PRs are open in all affected repos</action>
  </step>

  <step n="18" goal="Code Reviewer: Run adversarial code review then handle all PR comments">
    <invoke-workflow config="{project-root}/_bmad/bmm/workflows/4-implementation/code-review/workflow.yaml" />
    <action>The code-review workflow includes PR comment handling (steps 6–8):
      - Step 6: Discover and read all PR comments across every repo with an open PR for this story's feature branch
      - Step 7: For each comment — fix code if needed, run quality gate, commit and push fix, respond to comment, resolve thread
      - Step 8: Once all threads are resolved on a PR, post a merge summary comment and merge the PR (squash + delete branch)
    </action>
    <ask>
      ## Phase 8 Complete — Code Review and PR Comment Resolution Done

      The adversarial code review ran and all PR comments have been addressed and resolved.
      PRs with all threads resolved have been merged.

      See the Merge Summary table above for per-repo merge status.

      Type CONFIRM to finalize the story lifecycle.
      Or describe any remaining issues or re-review requests to handle.
    </ask>
  </step>

  <!-- ═══════════════════════════════════════════════════════
       COMPLETE
       ═══════════════════════════════════════════════════════ -->

  <step n="19" goal="Story lifecycle complete">
    <action>Output a final Lifecycle Summary:
      - Story key and title
      - All 8 phases completed with brief status per phase
      - Feature branch name
      - Railway preview URL
      - Pull requests created and merged (one row per repo with commits): repo | PR number | PR URL | Merge status
      - Total files changed (across all repos)
      - Final test coverage achieved
      - Total PR comments resolved
    </action>
    <action>Remind {user_name}: All PRs have been reviewed, comment-resolved, and merged to main</action>
  </step>

</workflow>
